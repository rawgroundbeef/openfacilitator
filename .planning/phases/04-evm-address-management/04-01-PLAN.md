---
phase: 04-evm-address-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/utils/evm-verify.ts
  - packages/server/src/routes/rewards.ts
  - apps/dashboard/src/config/wagmi.ts
  - apps/dashboard/src/components/providers/evm-provider.tsx
  - apps/dashboard/src/components/providers.tsx
  - apps/dashboard/src/lib/evm/verification.ts
  - apps/dashboard/src/components/rewards/enrollment-modal.tsx
autonomous: true

must_haves:
  truths:
    - "User can connect EVM wallet (MetaMask, injected) in enrollment modal"
    - "User can sign verification message with EVM wallet"
    - "Server verifies EIP-191 signature and saves address as verified"
    - "EVM addresses display in address list with 'EVM' badge"
  artifacts:
    - path: "packages/server/src/utils/evm-verify.ts"
      provides: "EIP-191 signature verification"
      exports: ["createEVMVerificationMessage", "verifyEVMSignature"]
    - path: "apps/dashboard/src/config/wagmi.ts"
      provides: "Wagmi configuration"
      exports: ["wagmiConfig"]
    - path: "apps/dashboard/src/components/providers/evm-provider.tsx"
      provides: "Wagmi provider wrapper"
      exports: ["EVMProvider"]
    - path: "apps/dashboard/src/lib/evm/verification.ts"
      provides: "Client-side EVM signing"
      exports: ["createVerificationMessage", "signAndEnrollEVM"]
  key_links:
    - from: "enrollment-modal.tsx"
      to: "wagmi hooks"
      via: "useAccount, useConnect, useSignMessage"
      pattern: "useSignMessage"
    - from: "enrollment-modal.tsx"
      to: "/api/rewards/enroll"
      via: "api.enrollInRewards with chain_type: 'evm'"
      pattern: "chain_type.*evm"
    - from: "packages/server/src/routes/rewards.ts"
      to: "packages/server/src/utils/evm-verify.ts"
      via: "import and call verifyEVMSignature"
      pattern: "verifyEVMSignature"
---

<objective>
Add EVM address enrollment to the rewards program, mirroring the Solana flow from Phase 3.

Purpose: Allow users to register EVM pay-to addresses (Ethereum, Base, Polygon) for rewards tracking, expanding the program beyond Solana-only addresses.

Output: Users can connect an EVM wallet, sign a verification message, and have their EVM address added to their rewards account with verified status.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-evm-address-management/04-RESEARCH.md

# Prior phase context (patterns to follow)
@.planning/phases/03-solana-address-management/03-01-SUMMARY.md
@.planning/phases/03-solana-address-management/03-02-SUMMARY.md

# Existing code to extend
@packages/server/src/routes/rewards.ts
@packages/server/src/utils/solana-verify.ts
@apps/dashboard/src/components/rewards/enrollment-modal.tsx
@apps/dashboard/src/components/providers.tsx
@apps/dashboard/src/lib/solana/verification.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Server-side EVM signature verification</name>
  <files>
    packages/server/src/utils/evm-verify.ts
    packages/server/src/routes/rewards.ts
  </files>
  <action>
Create EVM verification utility that mirrors the Solana pattern:

**packages/server/src/utils/evm-verify.ts:**

```typescript
import { verifyMessage, getAddress, isAddress } from 'viem';

/**
 * Create verification message for EVM address.
 * MUST match client-side createVerificationMessage exactly.
 */
export function createEVMVerificationMessage(address: string): string {
  return `OpenFacilitator Rewards

Sign to verify ownership of:
${address}

This will not cost any ETH.`;
}

/**
 * Verify an EIP-191 signature from an EVM wallet.
 * Uses viem's verifyMessage which handles the Ethereum prefix internally.
 */
export async function verifyEVMSignature(
  address: string,
  signature: string,
  message: string
): Promise<boolean> {
  try {
    if (!isAddress(address, { strict: false })) {
      return false;
    }

    // verifyMessage needs checksum address
    const checksumAddress = getAddress(address);

    return await verifyMessage({
      address: checksumAddress,
      message,
      signature: signature as `0x${string}`,
    });
  } catch {
    return false;
  }
}
```

**packages/server/src/routes/rewards.ts:**

Update the `/enroll` endpoint to handle EVM signatures:

1. Import the new EVM verification functions at the top:
   ```typescript
   import {
     verifyEVMSignature,
     createEVMVerificationMessage,
   } from '../utils/evm-verify.js';
   ```

2. Replace the "Only Solana addresses supported" check (lines 88-94) with EVM handling:
   ```typescript
   // Verify signature based on chain type
   if (chain_type === 'solana') {
     const expectedMessage = createVerificationMessage(address);
     if (message !== expectedMessage) {
       res.status(400).json({
         error: 'Validation error',
         message: 'Message format mismatch',
       });
       return;
     }

     if (!verifySolanaSignature(address, signature, message)) {
       res.status(400).json({
         error: 'Validation error',
         message: 'Invalid signature - could not verify address ownership',
       });
       return;
     }
   } else if (chain_type === 'evm') {
     const expectedMessage = createEVMVerificationMessage(address);
     if (message !== expectedMessage) {
       res.status(400).json({
         error: 'Validation error',
         message: 'Message format mismatch',
       });
       return;
     }

     if (!await verifyEVMSignature(address, signature, message)) {
       res.status(400).json({
         error: 'Validation error',
         message: 'Invalid signature - could not verify address ownership',
       });
       return;
     }
   }
   ```

Note: The handler needs `async` since verifyEVMSignature is async. The existing handler already has `async` in its signature.
  </action>
  <verify>
    - `pnpm build` succeeds in packages/server
    - No TypeScript errors
    - Grep for "verifyEVMSignature" in rewards.ts confirms integration
  </verify>
  <done>
    Server accepts EVM signatures at POST /api/rewards/enroll with chain_type: 'evm'
  </done>
</task>

<task type="auto">
  <name>Task 2: Wagmi provider and EVM client verification</name>
  <files>
    apps/dashboard/src/config/wagmi.ts
    apps/dashboard/src/components/providers/evm-provider.tsx
    apps/dashboard/src/components/providers.tsx
    apps/dashboard/src/lib/evm/verification.ts
  </files>
  <action>
Set up wagmi infrastructure and client-side EVM signing:

**apps/dashboard/src/config/wagmi.ts:**

```typescript
import { createConfig, http, cookieStorage, createStorage } from 'wagmi';
import { mainnet, base, polygon } from 'wagmi/chains';
import { injected, metaMask, safe } from 'wagmi/connectors';

export const wagmiConfig = createConfig({
  chains: [mainnet, base, polygon],
  connectors: [
    injected(),
    metaMask(),
    safe(),
  ],
  ssr: true,
  storage: createStorage({
    storage: cookieStorage,
  }),
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
    [polygon.id]: http(),
  },
});
```

**apps/dashboard/src/components/providers/evm-provider.tsx:**

```typescript
'use client';

import { WagmiProvider, type State } from 'wagmi';
import { wagmiConfig } from '@/config/wagmi';

export function EVMProvider({
  children,
  initialState
}: {
  children: React.ReactNode;
  initialState?: State;
}) {
  return (
    <WagmiProvider config={wagmiConfig} initialState={initialState}>
      {children}
    </WagmiProvider>
  );
}
```

**apps/dashboard/src/components/providers.tsx:**

Add EVMProvider to the provider tree, wrapping alongside SolanaProvider:

1. Add import: `import { EVMProvider } from './providers/evm-provider';`
2. Wrap children with EVMProvider (inside QueryClientProvider, alongside SolanaProvider):

```typescript
return (
  <QueryClientProvider client={queryClient}>
    <ThemeProvider attribute="class" defaultTheme="system" enableSystem disableTransitionOnChange>
      <EVMProvider>
        <SolanaProvider>
          <AuthProvider>{children}</AuthProvider>
        </SolanaProvider>
      </EVMProvider>
    </ThemeProvider>
  </QueryClientProvider>
);
```

**apps/dashboard/src/lib/evm/verification.ts:**

```typescript
'use client';

import { api } from '@/lib/api';

/**
 * Create the verification message for an EVM address.
 * MUST match server-side createEVMVerificationMessage exactly.
 */
export function createVerificationMessage(address: string): string {
  return `OpenFacilitator Rewards

Sign to verify ownership of:
${address}

This will not cost any ETH.`;
}

/**
 * Sign verification message and enroll EVM address.
 * @param signMessageAsync - From useSignMessage hook
 * @param address - Connected wallet address
 */
export async function signAndEnrollEVM(
  signMessageAsync: (args: { message: string }) => Promise<`0x${string}`>,
  address: string
): Promise<{ success: boolean; error?: string }> {
  const message = createVerificationMessage(address);

  try {
    const signature = await signMessageAsync({ message });

    await api.enrollInRewards({
      chain_type: 'evm',
      address,
      signature,
      message,
    });

    return { success: true };
  } catch (error) {
    if (error instanceof Error) {
      // Handle user rejection gracefully
      if (error.message.includes('rejected') || error.message.includes('denied') || error.message.includes('User rejected')) {
        return { success: false, error: 'Signature request was rejected' };
      }
      return { success: false, error: error.message };
    }
    return { success: false, error: 'Unknown error' };
  }
}
```
  </action>
  <verify>
    - `pnpm build` succeeds in apps/dashboard
    - No TypeScript errors
    - Files exist: wagmi.ts, evm-provider.tsx, evm/verification.ts
  </verify>
  <done>
    Wagmi provider configured and EVM signing utility ready for enrollment modal
  </done>
</task>

<task type="auto">
  <name>Task 3: Update enrollment modal with chain selector</name>
  <files>
    apps/dashboard/src/components/rewards/enrollment-modal.tsx
  </files>
  <action>
Update enrollment modal to support both Solana and EVM wallets:

**Refactor enrollment-modal.tsx:**

1. Add imports for wagmi hooks and EVM verification:
   ```typescript
   import { useAccount, useConnect, useSignMessage, useDisconnect as useEVMDisconnect, useConnectors } from 'wagmi';
   import { signAndEnrollEVM } from '@/lib/evm/verification';
   ```

2. Add state for chain selection:
   ```typescript
   type ChainType = 'solana' | 'evm';
   // In component:
   const [chainType, setChainType] = useState<ChainType>('solana');
   ```

3. Add wagmi hooks (call unconditionally at top level):
   ```typescript
   const { address: evmAddress, isConnected: evmConnected } = useAccount();
   const { connect: evmConnect } = useConnect();
   const { signMessageAsync } = useSignMessage();
   const { disconnect: evmDisconnect } = useEVMDisconnect();
   const connectors = useConnectors();
   ```

4. Create chain selector UI (tabs or toggle) at the top of the modal content:
   ```tsx
   <div className="flex gap-2 mb-6">
     <Button
       variant={chainType === 'solana' ? 'default' : 'outline'}
       size="sm"
       onClick={() => setChainType('solana')}
     >
       Solana
     </Button>
     <Button
       variant={chainType === 'evm' ? 'default' : 'outline'}
       size="sm"
       onClick={() => setChainType('evm')}
     >
       EVM
     </Button>
   </div>
   ```

5. Update idle state to show appropriate wallet connect based on chainType:
   - For Solana: Keep existing "Connect Wallet" button that calls handleConnect (opens Solana modal)
   - For EVM: Show connector buttons from wagmi:
   ```tsx
   {chainType === 'evm' && (
     <div className="flex flex-col gap-2 w-full">
       {connectors.map((connector) => (
         <Button
           key={connector.uid}
           variant="outline"
           onClick={() => {
             setStatus('connecting');
             evmConnect({ connector });
           }}
         >
           {connector.name}
         </Button>
       ))}
     </div>
   )}
   ```

6. Add useEffect to handle EVM connection -> auto-sign:
   ```typescript
   useEffect(() => {
     if (status === 'connecting' && chainType === 'evm' && evmConnected && evmAddress) {
       handleEVMSign();
     }
   }, [evmConnected, evmAddress, status, chainType]);
   ```

7. Add handleEVMSign function:
   ```typescript
   const handleEVMSign = useCallback(async () => {
     if (!evmAddress) return;
     setStatus('signing');
     setErrorMessage(null);

     const result = await signAndEnrollEVM(signMessageAsync, evmAddress);

     if (result.success) {
       await refetchRewardsStatus();
       setStatus('success');
     } else {
       setErrorMessage(result.error || 'Failed to verify address');
       setStatus('error');
     }
   }, [evmAddress, signMessageAsync, refetchRewardsStatus]);
   ```

8. Update handleTryAgain and handleAddAnother to disconnect both wallet types:
   ```typescript
   const handleTryAgain = useCallback(() => {
     setStatus('idle');
     setErrorMessage(null);
     disconnect(); // Solana
     evmDisconnect(); // EVM
   }, [disconnect, evmDisconnect]);
   ```

9. Update handleClose to disconnect both wallet types.

10. Update the cost disclaimer text based on chainType:
    - Solana: "This will not cost any SOL."
    - EVM: "This will not cost any ETH."
  </action>
  <verify>
    - `pnpm build` succeeds in apps/dashboard
    - No TypeScript errors
    - Manually test: Start dev server, open enrollment modal, verify chain selector appears
  </verify>
  <done>
    Enrollment modal supports both Solana and EVM address registration with chain selector tabs
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   - `pnpm build` succeeds in root (all packages)

2. **Integration test:**
   - Start dev servers: `pnpm dev`
   - Log in to dashboard
   - Click "Register Pay-To Address" on rewards banner
   - Verify chain selector (Solana/EVM tabs) appears
   - Select EVM tab
   - Connect MetaMask or other EVM wallet
   - Sign verification message
   - Verify address appears in list with "EVM" badge

3. **Code verification:**
   - Grep confirms: `verifyEVMSignature` called in rewards.ts
   - Grep confirms: `chain_type.*evm` in enrollment flow
   - Grep confirms: `WagmiProvider` in provider tree
</verification>

<success_criteria>
1. User can select "EVM" chain type in enrollment modal
2. User can connect EVM wallet (MetaMask, injected wallets)
3. User can sign verification message with EVM wallet
4. Server verifies EIP-191 signature using viem
5. Verified EVM address appears in address list
6. All builds pass with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-evm-address-management/04-01-SUMMARY.md`
</output>
