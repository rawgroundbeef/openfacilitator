---
phase: 12-sdk-type-definitions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/sdk/src/types.ts
autonomous: true

must_haves:
  truths:
    - "TypeScript narrows PaymentPayload to PaymentPayloadV1 when x402Version === 1"
    - "TypeScript narrows PaymentPayload to PaymentPayloadV2 when x402Version === 2"
    - "PaymentRequirements union supports both v1 and v2 field structures"
    - "Existing code using PaymentPayload continues to compile"
  artifacts:
    - path: "packages/sdk/src/types.ts"
      provides: "Versioned payment payload and requirements types"
      contains: "interface PaymentPayloadV1"
      exports: ["PaymentPayloadV1", "PaymentPayloadV2", "PaymentPayload", "PaymentRequirementsV1", "PaymentRequirementsV2", "PaymentRequirements"]
  key_links:
    - from: "PaymentPayloadV1"
      to: "PaymentPayload"
      via: "union member"
      pattern: "PaymentPayload = PaymentPayloadV1 \\| PaymentPayloadV2"
    - from: "PaymentPayloadV2"
      to: "PaymentPayload"
      via: "union member"
      pattern: "PaymentPayload = PaymentPayloadV1 \\| PaymentPayloadV2"
---

<objective>
Define versioned PaymentPayload and PaymentRequirements TypeScript types with discriminated unions.

Purpose: Enable TypeScript consumers to discriminate between v1 and v2 payment payloads with compile-time type narrowing via literal `x402Version` discriminants.

Output: Updated `types.ts` with PaymentPayloadV1, PaymentPayloadV2, PaymentRequirementsV1, PaymentRequirementsV2 interfaces and their union types.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-sdk-type-definitions/12-CONTEXT.md
@.planning/phases/12-sdk-type-definitions/12-RESEARCH.md
@packages/sdk/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define versioned PaymentPayload interfaces</name>
  <files>packages/sdk/src/types.ts</files>
  <action>
In `packages/sdk/src/types.ts`, replace the existing `PaymentPayload` interface with versioned interfaces:

1. Define `PaymentPayloadV1` interface:
   - `x402Version: 1` (literal type, not `number`)
   - `scheme: string`
   - `network: string` (v1 format: "base", "solana")
   - `payload: { signature: string; authorization: PaymentAuthorization; }`
   - Add JSDoc: `/** Payment payload for x402 version 1. Uses flat structure with scheme/network at top level. */`

2. Define `PaymentPayloadV2` interface:
   - `x402Version: 2` (literal type, not `number`)
   - `scheme: string`
   - `network: string` (v2 CAIP-2 format: "eip155:8453", "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp")
   - `payload: { signature: string; authorization: PaymentAuthorization; }`
   - Add JSDoc: `/** Payment payload for x402 version 2. Uses CAIP-2 network identifiers. */`

3. Update `PaymentPayload` to be a union type:
   ```typescript
   /**
    * Payment payload union - supports both x402 v1 and v2 formats.
    * Use x402Version to discriminate between versions.
    */
   export type PaymentPayload = PaymentPayloadV1 | PaymentPayloadV2;
   ```

4. Export both versioned interfaces (they're already exported by being `export interface`).

IMPORTANT: Use literal types `1` and `2`, NOT `number`. This enables TypeScript narrowing.
IMPORTANT: Keep PaymentPayload as the same name (now a type alias to the union) for backward compatibility.
  </action>
  <verify>
Run `pnpm --filter=@openfacilitator/sdk build` - should succeed with no type errors.
Verify in types.ts that PaymentPayloadV1 has `x402Version: 1` (literal) and PaymentPayloadV2 has `x402Version: 2` (literal).
  </verify>
  <done>
PaymentPayloadV1 and PaymentPayloadV2 interfaces exist with literal version discriminants.
PaymentPayload is a union type of both versions.
SDK builds successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Define versioned PaymentRequirements interfaces</name>
  <files>packages/sdk/src/types.ts</files>
  <action>
In `packages/sdk/src/types.ts`, update the PaymentRequirements section:

1. Rename existing `PaymentRequirements` to `PaymentRequirementsV1`:
   - Add JSDoc: `/** Payment requirements for x402 version 1. Uses maxAmountRequired field. */`
   - Keep all existing fields: scheme, network, maxAmountRequired, resource?, asset, payTo?, description?, mimeType?, maxTimeoutSeconds?, outputSchema?, extra?

2. Define `PaymentRequirementsV2` interface:
   ```typescript
   /**
    * Payment requirements for x402 version 2.
    * Uses 'amount' instead of 'maxAmountRequired' and has stricter required fields.
    */
   export interface PaymentRequirementsV2 {
     /** Payment scheme (e.g., "exact") */
     scheme: string;
     /** Network identifier - v2 CAIP-2 format */
     network: string;
     /** Amount required in base units */
     amount: string;
     /** Token/asset address */
     asset: string;
     /** Recipient address */
     payTo: string;
     /** Maximum timeout in seconds */
     maxTimeoutSeconds: number;
     /** Extra data */
     extra: Record<string, unknown>;
   }
   ```

3. Create union type:
   ```typescript
   /**
    * Payment requirements union - supports both v1 and v2 formats.
    * V1 uses maxAmountRequired, V2 uses amount.
    */
   export type PaymentRequirements = PaymentRequirementsV1 | PaymentRequirementsV2;
   ```

NOTE: PaymentRequirements does NOT have an x402Version discriminant field. Discrimination is done by checking for `maxAmountRequired` (v1) vs `amount` (v2) field presence, or by context from the associated PaymentPayload version.
  </action>
  <verify>
Run `pnpm --filter=@openfacilitator/sdk build` - should succeed with no type errors.
Verify types.ts exports PaymentRequirementsV1, PaymentRequirementsV2, and PaymentRequirements union.
  </verify>
  <done>
PaymentRequirementsV1 (with maxAmountRequired) and PaymentRequirementsV2 (with amount) interfaces exist.
PaymentRequirements is a union type of both versions.
SDK builds successfully with both tasks complete.
  </done>
</task>

</tasks>

<verification>
1. SDK builds: `pnpm --filter=@openfacilitator/sdk build` succeeds
2. Type narrowing works - create a quick TypeScript check:
   ```typescript
   // In a test file or playground:
   function testNarrowing(p: PaymentPayload) {
     if (p.x402Version === 1) {
       // Should narrow to PaymentPayloadV1
       const v1: PaymentPayloadV1 = p;  // Should compile
     } else {
       // Should narrow to PaymentPayloadV2
       const v2: PaymentPayloadV2 = p;  // Should compile
     }
   }
   ```
3. Existing code compiles: `pnpm --filter=@openfacilitator/sdk typecheck` (or build covers this)
</verification>

<success_criteria>
- PaymentPayloadV1 interface with literal `x402Version: 1`
- PaymentPayloadV2 interface with literal `x402Version: 2`
- PaymentPayload union correctly narrows when version is checked
- PaymentRequirementsV1 with maxAmountRequired field
- PaymentRequirementsV2 with amount field
- PaymentRequirements union supports both versions
- SDK builds with `pnpm --filter=@openfacilitator/sdk build`
- No breaking changes to existing PaymentPayload consumers
</success_criteria>

<output>
After completion, create `.planning/phases/12-sdk-type-definitions/12-01-SUMMARY.md`
</output>
